/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.pepsoft.worldpainter;

import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.*;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import org.pepsoft.worldpainter.biomeschemes.BiomeHelper;
import org.pepsoft.worldpainter.biomeschemes.CustomBiomeManager;
import org.pepsoft.worldpainter.layers.Annotations;
import org.pepsoft.worldpainter.layers.Biome;
import org.pepsoft.worldpainter.layers.GardenCategory;
import org.pepsoft.worldpainter.layers.Layer;

import static org.pepsoft.worldpainter.Constants.*;

/**
 *
 * @author pepijn
 */
public class InfoPanel extends javax.swing.JPanel {
    /**
     * Creates new form InfoPanel
     */
    public InfoPanel(WorldPainter view, CustomBiomeManager customBiomeManager) {
        this.view = view;
        listModel = new LayerListModel(customBiomeManager);
        
        initComponents();

//        updateTimer = new Timer(100, e -> updateInfo());
//        updateTimer.setRepeats(false);
        view.addMouseMotionListener(new MouseAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                worldCoords = view.viewToWorld(e.getX(), e.getY());
                updateInfo();
//                if (updateTimer.isRunning()) {
//                    updateTimer.restart();
//                } else {
//                    updateTimer.start();
//                }
            }
        });

        
        jList1.setModel(listModel);
    }

    public void updateInfo() {
        // TODO: alleen slope en layers ergens weergeven; de rest staat al in de status bar

        Dimension dim = view.getDimension();
        labelCoords.setText(worldCoords.x + "," + worldCoords.y);
        Tile tile = dim.getTile(worldCoords.x >> TILE_SIZE_BITS, worldCoords.y >> TILE_SIZE_BITS);
        if (tile != null) {
            final int x = worldCoords.x & TILE_SIZE_MASK, y = worldCoords.y & TILE_SIZE_MASK;
            int height = tile.getIntHeight(x, y);
            labelHeight.setText(Integer.toString(height));
            int waterLevel = tile.getWaterLevel(x, y);
            labelWaterLevel.setText(Integer.toString(waterLevel));
            if (waterLevel > height) {
                labelWaterDepth.setText(Integer.toString(waterLevel - height));
            } else {
                labelWaterDepth.setText(null);
            }
            if ((x > 0) && (x < TILE_SIZE - 1) && (y > 0) && (y < TILE_SIZE - 1)) {
                labelSlope.setText(Float.toString(tile.getSlope(x, y)));
            } else {
                labelSlope.setText(Float.toString(dim.getSlope(worldCoords.x, worldCoords.y)));
            }
            Map<Layer, Integer> layerValues = tile.getLayersAt(x, y);
            if (layerValues != null) {
                listModel.update(layerValues);
            } else {
                listModel.clear();
            }
        }
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        labelSlope = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jLabel5 = new javax.swing.JLabel();
        labelCoords = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        labelHeight = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        labelFluidType = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        labelWaterLevel = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        labelWaterDepth = new javax.swing.JLabel();
        jLabel17 = new javax.swing.JLabel();

        jLabel1.setText("Slope:");

        jLabel2.setText("Layers:");

        labelSlope.setText("jLabel5");

        jList1.setModel(new javax.swing.AbstractListModel() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(jList1);

        jLabel5.setText("Coordinates:");

        labelCoords.setText("jLabel6");

        jLabel7.setText("Height:");

        labelHeight.setText("jLabel8");

        jLabel10.setText("m");

        labelFluidType.setText("Fluid");

        jLabel12.setText("level:");

        jLabel13.setText("depth:");

        labelWaterLevel.setText("jLabel14");

        jLabel15.setText("m");

        labelWaterDepth.setText("jLabel16");

        jLabel17.setText("m");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel5)
                                    .addComponent(jLabel1)
                                    .addComponent(jLabel7))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(labelCoords)
                                    .addComponent(labelSlope)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(labelHeight)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel10))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(labelWaterLevel)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel15))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(labelWaterDepth)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel17))))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(labelFluidType)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel13)
                                    .addComponent(jLabel12))))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(labelCoords))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel7)
                    .addComponent(labelHeight)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelFluidType)
                    .addComponent(jLabel12)
                    .addComponent(labelWaterLevel)
                    .addComponent(jLabel15))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel13)
                    .addComponent(labelWaterDepth)
                    .addComponent(jLabel17))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(labelSlope))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JList jList1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel labelCoords;
    private javax.swing.JLabel labelFluidType;
    private javax.swing.JLabel labelHeight;
    private javax.swing.JLabel labelSlope;
    private javax.swing.JLabel labelWaterDepth;
    private javax.swing.JLabel labelWaterLevel;
    // End of variables declaration//GEN-END:variables

    private final WorldPainter view;
    private final LayerListModel listModel;
//    private final Timer updateTimer;
    private Point worldCoords;
    
    static class LayerListModel implements ListModel<JLabel> {
        public LayerListModel(CustomBiomeManager customBiomeManager) {
            this.biomeHelper = new BiomeHelper(null, null, customBiomeManager);
        }
        
        void update(Map<Layer, Integer> intensities) {
            if (labels.isEmpty()) {
                int index = 0;
                for (Map.Entry<Layer, Integer> entry: intensities.entrySet()) {
                    Layer layer = entry.getKey();
                    int intensity = entry.getValue();
                    JLabel label = new JLabel(layer.getName() + ": "+ getIntensity(layer, intensity), new ImageIcon(layer.getIcon()), JLabel.LEADING);
                    labels.add(label);
                    layerIndices.put(layer, index++);
                    ListDataEvent event = new ListDataEvent(this, ListDataEvent.INTERVAL_ADDED, 0, labels.size() - 1);
                    for (ListDataListener listener: listeners) {
                        listener.intervalAdded(event);
                    }
                }
            } else if (! intensities.isEmpty()) {
                Set<Layer> oldLayers = new HashSet<>(layerIndices.keySet());
                for (Map.Entry<Layer, Integer> entry: intensities.entrySet()) {
                    Layer layer = entry.getKey();
                    int intensity = entry.getValue();
                    String newText = layer.getName() + ": "+ getIntensity(layer, intensity);
                    if (layerIndices.containsKey(layer)) {
                        // Layer is already on the list
                        int index = layerIndices.get(layer);
                        JLabel label = labels.get(index);
                        if (! newText.equals(label.getText())) {
                            label.setText(newText);
                            ListDataEvent event = new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, index, index);
                            for (ListDataListener listener: listeners) {
                                listener.contentsChanged(event);
                            }
                        }
                    } else {
                        // Layer is not on the list; add it (to the end, to
                        // limit the amount of repainting needed
                        int index = labels.size();
                        JLabel label = new JLabel(newText, new ImageIcon(layer.getIcon()), JLabel.LEADING);
                        labels.add(label);
                        layerIndices.put(layer, index);
                        ListDataEvent event = new ListDataEvent(this, ListDataEvent.INTERVAL_ADDED, index, index);
                        for (ListDataListener listener: listeners) {
                            listener.intervalAdded(event);
                        }
                    }
                }
                oldLayers.removeAll(intensities.keySet());
                for (Layer oldLayer: oldLayers) {
                    // Layer removed
                    int index = layerIndices.remove(oldLayer);
                    for (Map.Entry<Layer, Integer> entry: layerIndices.entrySet()) {
                        if (entry.getValue() > index) {
                            entry.setValue(entry.getValue() - 1);
                        }
                    }
                    labels.remove(index);
                    ListDataEvent event = new ListDataEvent(this, ListDataEvent.INTERVAL_REMOVED, index, index);
                    for (ListDataListener listener: listeners) {
                        listener.intervalRemoved(event);
                    }
                }
            }
        }

        void clear() {
            if (! labels.isEmpty()) {
                int oldSize = labels.size();
                labels.clear();
                layerIndices.clear();
                ListDataEvent event = new ListDataEvent(this, ListDataEvent.INTERVAL_REMOVED, 0, oldSize - 1);
                for (ListDataListener listener: listeners) {
                    listener.intervalRemoved(event);
                }
            }
        }
        
        // ListModel
        
        @Override
        public int getSize() {
            return labels.size();
        }

        @Override
        public JLabel getElementAt(int index) {
            return labels.get(index);
        }

        @Override
        public void addListDataListener(ListDataListener l) {
            listeners.add(l);
        }

        @Override
        public void removeListDataListener(ListDataListener l) {
            listeners.remove(l);
        }

        private String getIntensity(Layer layer, int intensity) {
            if (layer instanceof Biome) {
                return biomeHelper.getBiomeName(intensity);
            } else if (layer instanceof Annotations) {
                return org.pepsoft.minecraft.Constants.COLOUR_NAMES[intensity - ((intensity < 8) ? 1 : 0)];
            } else if (layer instanceof GardenCategory) {
                return GardenCategory.getLabel(intensity);
            } else {
                switch (layer.getDataSize()) {
                    case BIT:
                    case BIT_PER_CHUNK:
                        return intensity == 0 ? "off" : "on";
                    case NIBBLE:
                        int strength = (intensity > 0) ? ((intensity - 1) * 100  / 14 + 1): 0;
                        if ((strength == 51) || (strength == 101)) {
                            strength--;
                        }
                        return strength + "%";
                    case BYTE:
                        return (intensity * 100 / 255) + "%";
                    case NONE:
                        return "N/A";
                    default:
                        throw new UnsupportedOperationException();
                }
            }
        }
        
        private final BiomeHelper biomeHelper;
        private final List<JLabel> labels = new ArrayList<>();
        private final Map<Layer, Integer> layerIndices = new HashMap<>();
        private final List<ListDataListener> listeners = new ArrayList<>();
    }
}